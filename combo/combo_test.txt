Wed Sep 12 21:11:26 2018

COMBO_TEST
  Python version: 3.6.5
  Test the COMBO library.

BACKTRACK_TEST
  Python version: 3.6.5
  BACKTRACK supervises a backtrack search.
  We demonstrate by searching for a nonattacking arrangement
  of queens on a chessboard.

 8 4 1 3 6 2 7 5
 8 3 1 6 2 5 7 4
 8 2 5 3 1 7 4 6
 8 2 4 1 7 5 3 6
 7 5 3 1 6 8 2 4
 7 4 2 8 6 1 3 5
 7 4 2 5 8 1 3 6
 7 3 8 2 5 1 6 4
 7 3 1 6 8 5 2 4
 7 2 6 3 1 4 8 5
 7 2 4 1 8 5 3 6
 7 1 3 8 6 4 2 5
 6 8 2 4 1 7 5 3
 6 4 7 1 8 2 5 3
 6 4 7 1 3 5 2 8
 6 4 2 8 5 7 1 3
 6 4 1 5 8 2 7 3
 6 3 7 4 1 8 2 5
 6 3 7 2 8 5 1 4
 6 3 7 2 4 8 1 5
 6 3 5 8 1 4 2 7
 6 3 5 7 1 4 2 8
 6 3 1 8 5 2 4 7
 6 3 1 8 4 2 7 5
 6 3 1 7 5 8 2 4
 6 2 7 1 4 8 5 3
 6 2 7 1 3 5 8 4
 6 1 5 2 8 3 7 4
 5 8 4 1 7 2 6 3
 5 8 4 1 3 6 2 7
 5 7 4 1 3 8 6 2
 5 7 2 6 3 1 8 4
 5 7 2 6 3 1 4 8
 5 7 2 4 8 1 3 6
 5 7 1 4 2 8 6 3
 5 7 1 3 8 6 4 2
 5 3 8 4 7 1 6 2
 5 3 1 7 2 8 6 4
 5 3 1 6 8 2 4 7
 5 2 8 1 4 7 3 6
 5 2 6 1 7 4 8 3
 5 2 4 7 3 8 6 1
 5 2 4 6 8 3 1 7
 5 1 8 6 3 7 2 4
 5 1 8 4 2 7 3 6
 5 1 4 6 8 2 7 3
 4 8 5 3 1 7 2 6
 4 8 1 5 7 2 6 3
 4 8 1 3 6 2 7 5
 4 7 5 3 1 6 8 2
 4 7 5 2 6 1 3 8
 4 7 3 8 2 5 1 6
 4 7 1 8 5 2 6 3
 4 6 8 3 1 7 5 2
 4 6 8 2 7 1 3 5
 4 6 1 5 2 8 3 7
 4 2 8 6 1 3 5 7
 4 2 8 5 7 1 3 6
 4 2 7 5 1 8 6 3
 4 2 7 3 6 8 5 1
 4 2 7 3 6 8 1 5
 4 2 5 8 6 1 3 7
 4 1 5 8 6 3 7 2
 4 1 5 8 2 7 3 6
 3 8 4 7 1 6 2 5
 3 7 2 8 6 4 1 5
 3 7 2 8 5 1 4 6
 3 6 8 2 4 1 7 5
 3 6 8 1 5 7 2 4
 3 6 8 1 4 7 5 2
 3 6 4 2 8 5 7 1
 3 6 4 1 8 5 7 2
 3 6 2 7 5 1 8 4
 3 6 2 7 1 4 8 5
 3 6 2 5 8 1 7 4
 3 5 8 4 1 7 2 6
 3 5 7 1 4 2 8 6
 3 5 2 8 6 4 7 1
 3 5 2 8 1 7 4 6
 3 1 7 5 8 2 4 6
 2 8 6 1 3 5 7 4
 2 7 5 8 1 4 6 3
 2 7 3 6 8 5 1 4
 2 6 8 3 1 4 7 5
 2 6 1 7 4 8 3 5
 2 5 7 4 1 8 6 3
 2 5 7 1 3 8 6 4
 2 4 6 8 3 1 7 5
 1 7 5 8 2 4 6 3
 1 7 4 6 8 2 5 3
 1 6 8 3 7 4 2 5
 1 5 8 6 3 7 2 4

BACKTRACK_TEST:
  Normal end of execution.

BAL_SEQ_CHECK TEST
  Python version: 3.6.5
  BAL_SEQ_CHECK checks N and T(1:2*N).

  Check?   N    T(1:2*N)

       1   5 0 0 1 0 1
       0   5 1 1 0 1 0
       0   5 0 0 1 0 1

BAL_SEQ_CHECK_TEST:
  Normal end of execution.

BAL_SEQ_ENUM_TEST
  Python version: 3.6.5
  BAL_SEQ_ENUM enumerates balanced sequences of N terms.

   N       #

   0       1
   1       1
   2       2
   3       5
   4      14
   5      42
   6     132
   7     429
   8    1430
   9    4862
  10   16796

BAL_SEQ_ENUM_TEST:
  Normal end of execution.

BAL_SEQ_RANK_TEST
  Python version: 3.6.5
  BAL_SEQ_RANK ranks balanced sequences of N items.

  The element to be ranked is:
 0 0 1 0 1 1 0 0 1 1

  Computed rank: 21

BAL_SEQ_RANK_TEST:
  Normal end of execution.

BAL_SEQ_SUCCESSOR_TEST
  Python version: 3.6.5
  BAL_SEQ_SUCCESSOR lists balanced sequences of N items, one at a time.
 0 0 0 0 0 1 1 1 1 1
 0 0 0 0 1 0 1 1 1 1
 0 0 0 0 1 1 0 1 1 1
 0 0 0 0 1 1 1 0 1 1
 0 0 0 0 1 1 1 1 0 1
 0 0 0 1 0 0 1 1 1 1
 0 0 0 1 0 1 0 1 1 1
 0 0 0 1 0 1 1 0 1 1
 0 0 0 1 0 1 1 1 0 1
 0 0 0 1 1 0 0 1 1 1
 0 0 0 1 1 0 1 0 1 1
 0 0 0 1 1 0 1 1 0 1
 0 0 0 1 1 1 0 0 1 1
 0 0 0 1 1 1 0 1 0 1
 0 0 1 0 0 0 1 1 1 1
 0 0 1 0 0 1 0 1 1 1
 0 0 1 0 0 1 1 0 1 1
 0 0 1 0 0 1 1 1 0 1
 0 0 1 0 1 0 0 1 1 1
 0 0 1 0 1 0 1 0 1 1
 0 0 1 0 1 0 1 1 0 1
 0 0 1 0 1 1 0 0 1 1
 0 0 1 0 1 1 0 1 0 1
 0 0 1 1 0 0 0 1 1 1
 0 0 1 1 0 0 1 0 1 1
 0 0 1 1 0 0 1 1 0 1
 0 0 1 1 0 1 0 0 1 1
 0 0 1 1 0 1 0 1 0 1
 0 1 0 0 0 0 1 1 1 1
 0 1 0 0 0 1 0 1 1 1
 0 1 0 0 0 1 1 0 1 1
 0 1 0 0 0 1 1 1 0 1
 0 1 0 0 1 0 0 1 1 1
 0 1 0 0 1 0 1 0 1 1
 0 1 0 0 1 0 1 1 0 1
 0 1 0 0 1 1 0 0 1 1
 0 1 0 0 1 1 0 1 0 1
 0 1 0 1 0 0 0 1 1 1
 0 1 0 1 0 0 1 0 1 1
 0 1 0 1 0 0 1 1 0 1
 0 1 0 1 0 1 0 0 1 1
 0 1 0 1 0 1 0 1 0 1

BAL_SEQ_SUCCESSOR_TEST:
  Normal end of execution.

BAL_SEQ_TO_TABLEAU_TEST
  Python version: 3.6.5
  BAL_SEQ_TO_TABLEAU converts a balanced
  sequence to a tableau
  Balanced sequence: 0 0 1 1 0 0 1 1

  Tableau:

  Col:       0        1        2        3  
  Row
    0:       1        2        5        6  
    1:       3        4        7        8  

BAL_SEQ_TO_TABLEAU_TEST:
  Normal end of execution.

BAL_SEQ_UNRANK_TEST
  Python version: 3.6.5
  BAL_SEQ_UNRANK unranks a balanced sequence of N items.

  Rank = 21

  The element of that rank is:
 0 0 1 0 1 1 0 0 1 1

BAL_SEQ_UNRANK_TEST:
  Normal end of execution.

BELL_NUMBERS_TEST
  Python version: 3.6.5
  BELL_NUMBERS computes Bell numbers.

         0             1             1
         1             1             1
         2             2             2
         3             5             5
         4            15            15
         5            52            52
         6           203           203
         7           877           877
         8          4140          4140
         9         21147         21147
        10        115975        115975

BELL_NUMBERS_TEST:
  Normal end of execution.

BELL_VALUES_TEST:
  Python version: 3.6.5
  BELL_VALUES returns values of
  the Bell numbers.

     N        BELL(N)

     0           1
     1           1
     2           2
     3           5
     4          15
     5          52
     6         203
     7         877
     8        4140
     9       21147
    10      115975

BELL_VALUES_TEST:
  Normal end of execution.

CYCLE_CHECK TEST
  Python version: 3.6.5
  CYCLE_CHECK checks a permutation in cycle form.

  Permutation in cycle form:
  Number of cycles is 3

       5
       1   3   8   6
       2   4   7
  Check =  0

  Permutation in cycle form:
  Number of cycles is 0

  Check =  0

  Permutation in cycle form:
  Number of cycles is 3

       5
       1   3   8   6
       2   4
  Check =  0

  Permutation in cycle form:
  Number of cycles is 3

       5
       1   3  12   6
       2   4   7
  Check =  0

  Permutation in cycle form:
  Number of cycles is 3

       5
       1   3   8   5
       2   4   7
  Check =  0

  Permutation in cycle form:
  Number of cycles is 3

       5
       1   3   8   6
       2   4   7
  Check =  1

CYCLE_CHECK_TEST:
  Normal end of execution.

CYCLE_TO_PERM_TEST
  Python version: 3.6.5
  CYCLE_TO_PERM converts a permutation from
  cycle to array form.

  Permutation in cycle form:
  Number of cycles is 3

       4   2   5   3   1
       6
       7

  Corresponding permutation form:

     1   2   3   4   5   6   7
     4   5   1   2   3   6   7

CYCLE_TO_PERM_TEST:
  Normal end of execution.

DIST_ENUM_TEST
  Python version: 3.6.5
  DIST_ENUM enumerates distributions of N indistinguishable
  objects among M distinguishable slots:

      N:      0       1       2       3       4       5
   M
   0:        0      0      0      0      0      0
   1:        1      1      1      1      1      1
   2:        1      2      3      4      5      6
   3:        1      3      6     10     15     21
   4:        1      4     10     20     35     56
   5:        1      5     15     35     70    126
   6:        1      6     21     56    126    252
   7:        1      7     28     84    210    462
   8:        1      8     36    120    330    792
   9:        1      9     45    165    495   1287
  10:        1     10     55    220    715   2002

DIST_ENUM_TEST:
  Normal end of execution.

DIST_NEXT_TEST
  Python version: 3.6.5
  DIST_NEXT produces the "next" distribution of M
  indistinguishable objects among K distinguishable slots:

  Number of:
    indistinguishable objects = 5
    distinguishable slots =     3
    distributions is            21

        1:     0    0    5
        2:     0    1    4
        3:     0    2    3
        4:     0    3    2
        5:     0    4    1
        6:     0    5    0
        7:     1    0    4
        8:     1    1    3
        9:     1    2    2
       10:     1    3    1
       11:     1    4    0
       12:     2    0    3
       13:     2    1    2
       14:     2    2    1
       15:     2    3    0
       16:     3    0    2
       17:     3    1    1
       18:     3    2    0
       19:     4    0    1
       20:     4    1    0
       21:     5    0    0

DIST_NEXT_TEST:
  Normal end of execution.

EDGE_CHECK TEST
  Python version: 3.6.5
  EDGE_CHECK checks a graph described by edges.

  Check?  Nodes  Edges    EdgeList

       0     -5      3

  Edge list of graph:

  Col:       0        1        2  
  Row
    0:       1        2        3  
    1:       2        3        1  

       0      3     -1

  Edge list of graph:

  (None)

       0      3      3

  Edge list of graph:

  Col:       0        1        2  
  Row
    0:       1        2        3  
    1:       2        3        4  

       0      3      3

  Edge list of graph:

  Col:       0        1        2  
  Row
    0:       1        2        3  
    1:       2        2        1  

       0      3      3

  Edge list of graph:

  Col:       0        1        2  
  Row
    0:       1        2        2  
    1:       2        3        1  

       1      3      3

  Edge list of graph:

  Col:       0        1        2  
  Row
    0:       1        2        3  
    1:       2        3        1  

EDGE_CHECK_TEST:
  Normal end of execution.

EDGE_DEGREE_TEST
  Python version: 3.6.5
  EDGE_DEGREE determines the degree of each node in a graph.

  The edge array:

  Col:       0        1        2        3        4  
  Row
    0:       1        2        2        3        4  
    1:       2        3        4        4        5  

  The degree vector:

     0       1
     1       3
     2       2
     3       3
     4       1

EDGE_DEGREE_TEST:
  Normal end of execution.

EDGE_ENUM_TEST
  Python version: 3.6.5
  EDGE_ENUM enumerates the maximum number of edges
  possible in a graph of NODE_NUM nodes.

   NODE_NUM    EDGE_NUM(max)

          1           0
          2           1
          3           3
          4           6
          5          10
          6          15
          7          21
          8          28
          9          36
         10          45

EDGE_ENUM_TEST:
  Normal end of execution.

GAMMA_LOG_VALUES:
  Python version: 3.6.5
  GAMMA_LOG_VALUES stores values of
  the logarithm of the Gamma function.

      X            GAMMA_LOG(X)

      0.200000        1.5240638224307841
      0.400000        0.7966778177017837
      0.600000        0.3982338580692348
      0.800000        0.1520596783998375
      1.000000        0.0000000000000000
      1.100000       -0.0498724412598397
      1.200000       -0.0853740900033158
      1.300000       -0.1081748095078604
      1.400000       -0.1196129141723712
      1.500000       -0.1207822376352452
      1.600000       -0.1125917656967557
      1.700000       -0.0958076974070659
      1.800000       -0.0710838729143722
      1.900000       -0.0389842759230833
      2.000000        0.0000000000000000
      3.000000        0.6931471805599453
      4.000000        1.7917594692280550
     10.000000       12.8018274800814691
     20.000000       39.3398841871994946
     30.000000       71.2570389671680147

GAMMA_LOG_VALUES_TEST:
  Normal end of execution.

GRAY_CODE_CHECK TEST
  Python version: 3.6.5
  GRAY_CODE_CHECK checks N and T(1:N).

  Check?      N    T(1:N)

       True   5:     0   1   1   0   1
      False   5:     1   0   7   1   0
       True   5:     1   1   1   1   1

GRAY_CODE_CHECK_TEST:
  Normal end of execution.

GRAY_CODE_ENUM_TEST
  Python version: 3.6.5
  GRAY_CODE_ENUM enumerates Gray codes on N elements.

   N    Enum(N)

   0       1
   1       2
   2       4
   3       8
   4      16
   5      32
   6      64
   7     128
   8     256
   9     512
  10    1024

GRAY_CODE_ENUM_TEST:
  Normal end of execution.

GRAY_CODE_RANK_TEST
  Python version: 3.6.5
  GRAY_CODE_RANK ranks a given Gray code.

  Element to be ranked:

     0       1
     1       1
     2       0
     3       0
     4       0

  Computed rank: 16

GRAY_CODE_RANK_TEST:
  Normal end of execution.

GRAY_CODE_SUCCESSOR_TEST:
  Python version: 3.6.5
  GRAY_CODE_SUCCESSOR returns the next Gray code.

       0:     0   0   0   0   0
       1:     0   0   0   0   1
       2:     0   0   0   1   1
       3:     0   0   0   1   0
       4:     0   0   1   1   0
       5:     0   0   1   1   1
       6:     0   0   1   0   1
       7:     0   0   1   0   0
       8:     0   1   1   0   0
       9:     0   1   1   0   1
      10:     0   1   1   1   1
      11:     0   1   1   1   0
      12:     0   1   0   1   0
      13:     0   1   0   1   1
      14:     0   1   0   0   1
      15:     0   1   0   0   0
      16:     1   1   0   0   0
      17:     1   1   0   0   1
      18:     1   1   0   1   1
      19:     1   1   0   1   0
      20:     1   1   1   1   0
      21:     1   1   1   1   1
      22:     1   1   1   0   1
      23:     1   1   1   0   0
      24:     1   0   1   0   0
      25:     1   0   1   0   1
      26:     1   0   1   1   1
      27:     1   0   1   1   0
      28:     1   0   0   1   0
      29:     1   0   0   1   1
      30:     1   0   0   0   1
      31:     1   0   0   0   0

GRAY_CODE_SUCCESSOR_TEST:
  Normal end of execution.

GRAY_CODE_UNRANK_TEST
  Python version: 3.6.5
  GRAY_CODE_UNRANK unranks.

  Seek the element of rank 16

  The item of the given rank

     0       1
     1       1
     2       0
     3       0
     4       0

GRAY_CODE_UNRANK_TEST:
  Normal end of execution.

I4_CHOOSE_TEST
  Python version: 3.6.5
  I4_CHOOSE evaluates C(N,K).

       N       K     CNK

       0       0       1

       1       0       1
       1       1       1

       2       0       1
       2       1       2
       2       2       1

       3       0       1
       3       1       3
       3       2       3
       3       3       1

       4       0       1
       4       1       4
       4       2       6
       4       3       4
       4       4       1

I4_CHOOSE_TEST:
  Normal end of execution.

I4_FACTORIAL_TEST
  Python version: 3.6.5
  I4_FACTORIAL evaluates the factorial function.

         N      Exact         I4_FACTORIAL(N)

         0             1             1
         1             1             1
         2             2             2
         3             6             6
         4            24            24
         5           120           120
         6           720           720
         7          5040          5040
         8         40320         40320
         9        362880        362880
        10       3628800       3628800
        11      39916800      39916800
        12     479001600     479001600

I4_FACTORIAL_TEST
  Normal end of execution.

I4_FACTORIAL_VALUES_TEST:
  Python version: 3.6.5
  I4_FACTORIAL_VALUES returns values of the integer factorial function.

          N          I4_FACTORIAL(N)

         0             1
         1             1
         2             2
         3             6
         4            24
         5           120
         6           720
         7          5040
         8         40320
         9        362880
        10       3628800
        11      39916800
        12     479001600

I4_FACTORIAL_VALUES_TEST:
  Normal end of execution.

I4_FALL_TEST
  Python version: 3.6.5
  I4_FALL evaluates the falling factorial Fall(I,N).

         M         N      Exact         I4_FALL(M,N)

         5         0             1             1
         5         1             5             5
         5         2            20            20
         5         3            60            60
         5         4           120           120
         5         5           120           120
         5         6             0             0
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2            90            90
        18         3          4896          4896
         4         4            24            24
        98         3        912576        912576
         1         7             0             0

I4_FALL_TEST:
  Normal end of execution.

I4_FALL_VALUES_TEST:
  Python version: 3.6.5
  I4_FALL_VALUES returns values of the integer falling factorial.

          M         N          I4_FALL(M,N)

         5         0         1
         5         1         5
         5         2        20
         5         3        60
         5         4       120
         5         5       120
         5         6         0
        50         0         1
        10         1        10
      4000         1      4000
        10         2        90
        18         3      4896
         4         4        24
        98         3    912576
         1         7         0

I4_FALL_VALUES_TEST:
  Normal end of execution.

I4_HUGE_TEST
  Python version: 3.6.5
  I4_HUGE returns a huge integer.

  I4_HUGE() = 2147483647

I4_HUGE_TEST
  Normal end of execution.

I4_UNIFORM_AB_TEST
  Python version: 3.6.5
  I4_UNIFORM_AB computes pseudorandom values
  in an interval [A,B].

  The lower endpoint A = -100
  The upper endpoint B = 200
  The initial seed is 123456789

         1       -35
         2       187
         3       149
         4        69
         5        25
         6       -81
         7       -23
         8       -67
         9       -87
        10        90
        11       -82
        12        35
        13        20
        14       127
        15       139
        16      -100
        17       170
        18         5
        19       -72
        20       -96

I4_UNIFORM_AB_TEST:
  Normal end of execution.

I4MAT_PRINT_TEST:
  Python version: 3.6.5
  Test I4MAT_PRINT, which prints an I4MAT.

  A 5 x 6 integer matrix:

  Col:       0        1        2        3        4  
  Row
    0:      11       12       13       14       15  
    1:      21       22       23       24       25  
    2:      31       32       33       34       35  
    3:      41       42       43       44       45  
    4:      51       52       53       54       55  

  Col:       5  
  Row
    0:      16  
    1:      26  
    2:      36  
    3:      46  
    4:      56  

I4MAT_PRINT_TEST:
  Normal end of execution.

I4MAT_PRINT_SOME_TEST
  Python version: 3.6.5
  I4MAT_PRINT_SOME prints some of an I4MAT.

  Here is I4MAT, rows 0:2, cols 3:5:

  Col:       3        4        5  
  Row
    0:      14       15       16  
    1:      24       25       26  
    2:      34       35       36  

I4MAT_PRINT_SOME_TEST:
  Normal end of execution.

I4VEC_BACKTRACK_TEST
  Python version: 3.6.5
  I4VEC_BACKTRACK uses backtracking, seeking a vector X of
  N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1     53:    15  22  16
   2     53:    15  14  16  8
   3     53:    22  14  9  8

  Done!

I4VEC_BACKTRACK_TEST:
  Normal end of execution.

I4VEC_DOT_PRODUCT_TEST
  Python version: 3.6.5
  I4VEC_DOT_PRODUCT computes the dot product of two I4VECs.

  The vector A:

     0       2
     1      10
     2       9
     3       6
     4       4

  The vector B:

     0       0
     1       2
     2       1
     3       0
     4       6

  The dot product is 53

I4VEC_DOT_PRODUCT_TEST:
  Normal end of execution.

I4VEC_INDICATOR1_TEST
  Python version: 3.6.5
  I4VEC_INDICATOR1 returns an indicator vector.

  The indicator1 vector:

     0       1
     1       2
     2       3
     3       4
     4       5
     5       6
     6       7
     7       8
     8       9
     9      10

I4VEC_INDICATOR1_TEST
  Normal end of execution.

I4VEC_PART1_TEST:
  Python version: 3.6.5
  I4VEC_PART1 partitions an integer N into NPART parts.

  Partition N = 17 into NPART = 5 parts:

   0  13
   1   1
   2   1
   3   1
   4   1

I4VEC_PART1_TEST:
  Normal end of execution.

I4VEC_PART2_TEST:
  Python version: 3.6.5
  I4VEC_PART2 partitions an integer N into NPART parts.

  Partition N = 17 into NPART = 5 parts:

   0   4
   1   4
   2   3
   3   3
   4   3

I4VEC_PART2_TEST:
  Normal end of execution.

I4VEC_PRINT_TEST
  Python version: 3.6.5
  I4VEC_PRINT prints an I4VEC.

  Here is an I4VEC:

     0      91
     1      92
     2      93
     3      94

I4VEC_PRINT_TEST:
  Normal end of execution.

I4VEC_REVERSE_TEST
  Python version: 3.6.5
  I4VEC_REVERSE reverses a list of integers.

  Original vector:

     0       6
     1      29
     2      25
     3      17
     4      12
     5       2
     6       7
     7       3
     8       1
     9      19

  Reversed:

     0      19
     1       1
     2       3
     3       7
     4       2
     5      12
     6      17
     7      25
     8      29
     9       6

I4VEC_REVERSE_TEST:
  Normal end of execution.

I4VEC_SEARCH_BINARY_A_TEST
  Python version: 3.6.5
  I4VEC_SEARCH_BINARY_A searches a ascending sorted vector.

  Ascending sorted array:

     0       0
     1       1
     2       1
     3       2
     4       3
     5       4
     6       5
     7       6
     8       7
     9       8

  Now search for an instance of the value 5

  The value occurs at index = 6

I4VEC_SEARCH_BINARY_A_TEST
  Normal end of execution.

I4VEC_SEARCH_BINARY_D_TEST
  Python version: 3.6.5
  I4VEC_SEARCH_BINARY_D searches a descending sorted vector.

  Descending sorted array:

     0       8
     1       7
     2       6
     3       5
     4       4
     5       3
     6       2
     7       1
     8       1
     9       0

  Now search for an instance of the value 5

  The value occurs at index = 3

I4VEC_SEARCH_BINARY_D_TEST
  Normal end of execution.

I4VEC_SORT_INSERT_A_TEST
  Python version: 3.6.5
  I4VEC_SORT_INSERT_A sorts an integer array.

  Unsorted array:

     0       2
     1      10
     2       9
     3       6
     4       4
     5       0
     6       2
     7       1
     8       0
     9       6

  Sorted array:

     0       0
     1       0
     2       1
     3       2
     4       2
     5       4
     6       6
     7       6
     8       9
     9      10

I4VEC_SORT_INSERT_A_TEST
  Normal end of execution.

I4VEC_SORT_INSERT_D_TEST
  Python version: 3.6.5
  I4VEC_SORT_INSERT_D descending sorts an I4VEC.

  Unsorted array:

     0       2
     1      10
     2       9
     3       6
     4       4
     5       0
     6       2
     7       1
     8       0
     9       6

  Descending sorted array:

     0      10
     1       9
     2       6
     3       6
     4       4
     5       2
     6       2
     7       1
     8       0
     9       0

I4VEC_SORT_INSERT_D_TEST
  Normal end of execution.

I4VEC_UNIFORM_AB_TEST
  Python version: 3.6.5
  I4VEC_UNIFORM_AB computes pseudorandom values
  in an interval [A,B].

  The lower endpoint A = -100
  The upper endpoint B = 200
  The initial seed is 123456789


  The random vector:

     0     -35
     1     187
     2     149
     3      69
     4      25
     5     -81
     6     -23
     7     -67
     8     -87
     9      90
    10     -82
    11      35
    12      20
    13     127
    14     139
    15    -100
    16     170
    17       5
    18     -72
    19     -96

I4VEC_UNIFORM_AB_TEST:
  Normal end of execution.

KNAPSACK_01_TEST
  Python version: 3.6.5
  KNAPSACK_01 solves the 0/1 knapsack problem.

  Object, Profit, Mass, "Profit Density"

       0   24.000   12.000    2.000
       1   13.000    7.000    1.857
       2   23.000   11.000    2.091
       3   15.000    8.000    1.875
       4   16.000    9.000    1.778

  After reordering by Profit Density:

  Object, Profit, Mass, "Profit Density"

       0   23.000   11.000    2.091
       1   24.000   12.000    2.000
       2   15.000    8.000    1.875
       3   13.000    7.000    1.857
       4   16.000    9.000    1.778

  Total mass restriction is 26.000000

  Object, Density, Choice, Profit, Mass

     0    2.091    1.000   23.000   11.000
     1    2.000    0.000    0.000    0.000
     2    1.875    1.000   15.000    8.000
     3    1.857    1.000   13.000    7.000
     4    1.778    0.000    0.000    0.000

  Total:                   51.000   26.000

KNAPSACK_01_TEST:
  Normal end of execution.

KNAPSACK_RATIONAL_TEST
  Python version: 3.6.5
  KNAPSACK_RATIONAL solves the rational knapsack problem.

  Object, Profit, Mass, "Profit Density"

       0   24.000   12.000    2.000
       1   13.000    7.000    1.857
       2   23.000   11.000    2.091
       3   15.000    8.000    1.875
       4   16.000    9.000    1.778

  After reordering by Profit Density:

  Object, Profit, Mass, "Profit Density"

       0   23.000   11.000    2.091
       1   24.000   12.000    2.000
       2   15.000    8.000    1.875
       3   13.000    7.000    1.857
       4   16.000    9.000    1.778

  Total mass restriction is 26.000000

  Object, Density, Choice, Profit, Mass

     0    2.091    1.000   23.000   11.000
     1    2.000    1.000   24.000   12.000
     2    1.875    0.375    5.625    3.000
     3    1.857    0.000    0.000    0.000
     4    1.778    0.000    0.000    0.000

  Total:                   52.625   26.000

KNAPSACK_RATIONAL_TEST:
  Normal end of execution.

KNAPSACK_REORDER_TEST
  Python version: 3.6.5
  KNAPSACK_REORDER reorders knapsack data.

  Object, Profit, Mass, "Profit Density"

       0   24.000   12.000    2.000
       1   13.000    7.000    1.857
       2   23.000   11.000    2.091
       3   15.000    8.000    1.875
       4   16.000    9.000    1.778

  After reordering by Profit Density:

  Object, Profit, Mass, "Profit Density"

       0   23.000   11.000    2.091
       1   24.000   12.000    2.000
       2   15.000    8.000    1.875
       3   13.000    7.000    1.857
       4   16.000    9.000    1.778

KNAPSACK_REORDER_TEST:
  Normal end of execution.

KSUBSET_COLEX_CHECK TEST
  Python version: 3.6.5
  KSUBSET_COLEX_CHECK checks a K subset of an N set.
  Subset:(empty vector)
  N = 5, K = -1
  Check = False
  Subset: 5 3 2
  N = 0, K = 3
  Check = False
  Subset: 5 2 3
  N = 5, K = 3
  Check = False
  Subset: 7 3 2
  N = 5, K = 3
  Check = False
  Subset: 5 3 2
  N = 5, K = 3
  Check = True
  Subset:(empty vector)
  N = 5, K = 0
  Check = True
  Subset:(empty vector)
  N = 0, K = 0
  Check = True

KSUBSET_COLEX_CHECK_TEST:
  Normal end of execution.

KSUBSET_COLEX_RANK_TEST
  Python version: 3.6.5
  KSUBSET_COLEX_RANK ranks K-subsets of an N set,
  using the colexicographic ordering.
  The element to be ranked: 5 3 1

  The rank of the element is computed as 5.

KSUBSET_COLEX_RANK_TEST:
  Normal end of execution.

KSUBSET_COLEX_SUCCESSOR_TEST
  Python version: 3.6.5
  KSUBSET_COLEX_SUCCESSOR lists K-subsets of an N set,
  using the colexicographic ordering.

 3 2 1
 4 2 1
 4 3 1
 4 3 2
 5 2 1
 5 3 1
 5 4 1
 5 4 2
 5 4 3

KSUBSET_COLEX_SUCCESSOR_TEST:
  Normal end of execution.

KSUBSET_COLEX_UNRANK_TEST
  Python version: 3.6.5
  KSUBSET_COLEX_UNRANK unranks K-subsets of an N set,
  using the colexicographic ordering:

  The element of rank 5:


  The element:

     0       5
     1       3
     2       1

KSUBSET_COLEX_UNRANK_TEST:
  Normal end of execution.

KSUBSET_ENUM_TEST
  Python version: 3.6.5
  KSUBSET_ENUM enumerates K-subsets of an N set.

      K:   0    1    2    3    4    5
   N

   0:     1
   1:     1   1
   2:     1   2   1
   3:     1   3   3   1
   4:     1   4   6   4   1
   5:     1   5  10  10   5   1

KSUBSET_ENUM_TEST:
  Normal end of execution.

KSUBSET_LEX_CHECK TEST
  Python version: 3.6.5
  KSUBSET_LEX_CHECK checks a K subset of an N set.
  Subset:(empty vector)
  N = %d, K = %d (5, -1)
  Check = False
  Subset: 2 3 5
  N = %d, K = %d (0, 3)
  Check = False
  Subset: 3 2 5
  N = %d, K = %d (5, 3)
  Check = False
  Subset: 2 3 7
  N = %d, K = %d (5, 3)
  Check = False
  Subset: 2 3 5
  N = %d, K = %d (5, 3)
  Check = True
  Subset:(empty vector)
  N = %d, K = %d (5, 0)
  Check = True
  Subset:(empty vector)
  N = %d, K = %d (0, 0)
  Check = True

KSUBSET_LEX_CHECK_TEST:
  Normal end of execution.

KSUBSET_LEX_RANK_TEST
  Python version: 3.6.5
  KSUBSET_LEX_RANK ranks K-subsets of an N set,
  using the lexicographic ordering.
  The element to be ranked: 1 4 5

  The rank is computed as 5.

KSUBSET_LEX_RANK_TEST:
  Normal end of execution.

KSUBSET_LEX_SUCCESSOR_TEST
  Python version: 3.6.5
  KSUBSET_LEX_SUCCESSOR lists K-subsets of an N set,
  using the lexicographic ordering.
 1 2 3
 1 2 4
 1 2 5
 1 3 4
 1 3 5
 1 4 5
 2 3 4
 2 3 5
 2 4 5
 3 4 5

KSUBSET_LEX_SUCCESSOR_TEST:
  Normal end of execution.

KSUBSET_LEX_UNRANK_TEST
  Python version: 3.6.5
  KSUBSET_LEX_UNRANK unranks K-subsets of an N set,
  using the lexicographic ordering.
  The element of rank 5: 1 4 5

KSUBSET_LEX_UNRANK_TEST:
  Normal end of execution.

KSUBSET_REVDOOR_RANK_TEST
  Python version: 3.6.5
  KSUBSET_REVDOOR_RANK ranks K-subsets of an N set
  using the revolving door ordering.
  The K-subset to be ranked: 2 4 5

  The rank of the element is computed as 4

KSUBSET_REVDOOR_RANK_TEST:
  Normal end of execution.

KSUBSET_REVDOOR_SUCCESSOR_TEST
  Python version: 3.6.5
  KSUBSET_REVDOOR_SUCCESSOR lists K-subsets of an N set
  using the revolving door ordering.

 1 2 3
 1 3 4
 2 3 4
 1 2 4
 1 4 5
 2 4 5
 3 4 5
 1 3 5
 2 3 5
 1 2 5

KSUBSET_REVDOOR_SUCCESSOR_TEST:
  Normal end of execution.

KSUBSET_REVDOOR_UNRANK_TEST
  Python version: 3.6.5
  KSUBSET_REVDOOR_UNRANK unranks K-subsets of an N set
  using the revolving door ordering.
  The element of rank 5: 2 4 5

KSUBSET_REVDOOR_UNRANK_TEST:
  Normal end of execution.

MARRIAGE_TEST
  Python version: 3.6.5
  MARRIAGE arranges a set of stable marriages
  given a set of preferences.

  Man, Wife's rank, Wife

       1       3       1
       2       4       4
       3       3       5
       4       2       3
       5       3       2

  Woman, Husband's rank, Husband

       1       2       1
       2       2       5
       3       2       4
       4       2       2
       5       3       3

  Correct result:

  M:W 1  2  3  4  5
   1  +  .  .  .  .
   2  .  .  .  +  .
   3  .  .  .  .  +
   4  .  .  +  .  .
   5  .  +  .  .  .

MARRIAGE_TEST:
  Normal end of execution.

MOUNTAIN_TEST
  Python version: 3.6.5
  MOUNTAIN computes mountain numbers.

   Y    MXY

   0     42   0  14   0   5   0   2   0   1   0   1
   1      0  42   0  14   0   5   0   2   0   1   0
   2     90   0  28   0   9   0   3   0   1   0   0
   3      0  48   0  14   0   4   0   1   0   0   0
   4     75   0  20   0   5   0   1   0   0   0   0
   5      0  27   0   6   0   1   0   0   0   0   0

MOUNTAIN_TEST:
  Normal end of execution.

NPART_ENUM_TEST
  Python version: 3.6.5
  NPART_ENUM enumerates partitions of N into PART_NUM parts.

   PART_NUM:  1       2       3       4       5       6
   N
   0:  
   1:         1
   2:         1       1
   3:         1       1       1
   4:         1       2       1       1
   5:         1       2       2       1       1
   6:         1       3       3       2       1       1
   7:         1       3       4       3       2       1
   8:         1       4       5       5       3       2
   9:         1       4       7       6       5       3
  10:         1       5       8       9       7       5

NPART_ENUM_TEST:
  Normal end of execution.

NPART_RSF_LEX_RANDOM_TEST
  Python version: 3.6.5
  NPART_RSF_LEX_RANDOM produces random examples
  of partitions of N = 12
  with NPART = 3 parts
  in reverse standard form.

    1    4    7
    4    4    4
    3    4    5
    2    4    6
    2    2    8
    1    2    9
    1    5    6
    1    3    8
    1    2    9
    2    5    5

NPART_RSF_LEX_RANDOM_TEST:
  Normal end of execution.

NPART_RSF_LEX_RANK_TEST
  Python version: 3.6.5
  NPART_RSF_LEX_RANK ranks partitions of N with NPART parts
  in reverse standard form.
  Element: 1 5 6

  The rank of the element is computed as 4:

NPART_RSF_LEX_TEST:
  Normal end of execution.

NPART_RSF_LEX_SUCCESSOR_TEST
  Python version: 3.6.5
  NPART_RSF_LEX_SUCCESSOR lists
  partitions of N with NPART parts
  in reverse standard form.

 1 1 10
 1 2 9
 1 3 8
 1 4 7
 1 5 6
 2 2 8
 2 3 7
 2 4 6
 2 5 5
 3 3 6
 3 4 5
 4 4 4

NPART_RSF_LEX_SUCCESSOR_TEST:
  Normal end of execution.

NPART_RSF_LEX_UNRANK_TEST
  Python version: 3.6.5
  NPART_RSF_LEX_UNRANK unranks
  partitions of N with NPART parts
  in reverse standard form.
  The element of rank 4: 1 5 6

NPART_RSF_LEX_UNRANK_TEST:
  Normal end of execution.

NPART_SF_LEX_SUCCESSOR_TEST
  Python version: 3.6.5
  NPART_SF_LEX_SUCCESSOR lists
  Partitions of N with NPART parts
  in standard form.

  For N = 12
  and NPART = 3
  the number of partitions is 12

 4 4 4
 5 4 3
 5 5 2
 6 3 3
 6 4 2
 6 5 1
 7 3 2
 7 4 1
 8 2 2
 8 3 1
 9 2 1
 10 1 1

NPART_SF_LEX_SUCCESSOR_TEST:
  Normal end of execution.

NPART_TABLE_TEST
  Python version: 3.6.5
  NPART_TABLE tabulates partitions
  of N with NPART parts

    I P(I,0) P(I,1) P(I,2) P(I,3) P(I,4) P(I,5)

    0    1    0    0    0    0    0
    1    0    1    0    0    0    0
    2    0    1    1    0    0    0
    3    0    1    1    1    0    0
    4    0    1    2    1    1    0
    5    0    1    2    2    1    1
    6    0    1    3    3    2    1
    7    0    1    3    4    3    2
    8    0    1    4    5    5    3
    9    0    1    4    7    6    5
   10    0    1    5    8    9    7

NPART_TABLE_TEST:
  Normal end of execution.

PART_ENUM_TEST
  Python version: 3.6.5
  PART_ENUM enumerates partitions of N.

   N     #

   0       1
   1       1
   2       2
   3       3
   4       5
   5       8
   6      11
   7      15
   8      22
   9      30
  10      42

PART_ENUM_TEST:
  Normal end of execution.

PART_RSF_CHECK TEST
  Python version: 3.6.5
  PART_RSF_CHECK checks a reverse standard form partition.

  Partition in RSF form.
  Partition of N = 0
  Number of parts NPART = 4
 1 4 4 6
  Check = False

  Partition in RSF form.
  Partition of N = 15
  Number of parts NPART = 0
(empty vector)
  Check = False

  Partition in RSF form.
  Partition of N = 15
  Number of parts NPART = 4
 -9 4 4 16
  Check = False

  Partition in RSF form.
  Partition of N = 15
  Number of parts NPART = 4
 6 4 4 1
  Check = False

  Partition in RSF form.
  Partition of N = 15
  Number of parts NPART = 4
 1 4 5 6
  Check = False

  Partition in RSF form.
  Partition of N = 15
  Number of parts NPART = 4
 1 4 4 6
  Check = True

PART_RSF_CHECK_TEST:
  Normal end of execution.

PART_SF_CHECK TEST
  Python version: 3.6.5
  PART_SF_CHECK checks a standard form partition.

  Partition in SF form.
  Partition of N = 0
  Number of parts NPART = 4
 6 4 4 1
  Check = False

  Partition in SF form.
  Partition of N = 15
  Number of parts NPART = 0
(empty vector)
  Check = False

  Partition in SF form.
  Partition of N = 15
  Number of parts NPART = 4
 16 4 4 -9
  Check = False

  Partition in SF form.
  Partition of N = 15
  Number of parts NPART = 4
 1 4 4 6
  Check = False

  Partition in SF form.
  Partition of N = 15
  Number of parts NPART = 4
 6 5 4 1
  Check = False

  Partition in SF form.
  Partition of N = 15
  Number of parts NPART = 4
 6 4 4 1
  Check = True

PART_SF_CHECK_TEST:
  Normal end of execution.

PART_SF_CONJUGATE_TEST
  Python version: 3.6.5
  PART_SF_CONJUGATE produces the conjugate of a partition.

  Partitions of N = 8

  0
 1 1 1 1 1 1 1 1
 8

  1
 2 1 1 1 1 1 1
 7 1

  2
 2 2 1 1 1 1
 6 2

  3
 2 2 2 1 1
 5 3

  4
 2 2 2 2
 4 4

  5
 3 1 1 1 1 1
 6 1 1

  6
 3 2 1 1 1
 5 2 1

  7
 3 2 2 1
 4 3 1

  8
 3 3 1 1
 4 2 2

  9
 3 3 2
 3 3 2

  10
 4 1 1 1 1
 5 1 1 1

  11
 4 2 1 1
 4 2 1 1

  12
 4 2 2
 3 3 1 1

  13
 4 3 1
 3 2 2 1

  14
 4 4
 2 2 2 2

  15
 5 1 1 1
 4 1 1 1 1

  16
 5 2 1
 3 2 1 1 1

  17
 5 3
 2 2 2 1 1

  18
 6 1 1
 3 1 1 1 1 1

  19
 6 2
 2 2 1 1 1 1

  20
 7 1
 2 1 1 1 1 1 1

  21
 8
 1 1 1 1 1 1 1 1

PART_SF_CONJUGATE_TEST:
  Normal end of execution.

PART_SF_MAJORIZE_TEST
  Python version: 3.6.5
  PART_SF_MAJORIZE determines if one partition
  majorizes another.

  Partitions of N = 8

  A: 2 2 2 1 1
  B: 3 1 1 1 1 1
  C: 2 2 1 1 1 1

  A compare B: -2
  B compare C: 1
  C compare A: -1
  C compare C: 0

PART_SF_MAJORIZE_TEST:
  Normal end of execution.

PART_SUCCESSOR_TEST
  Python version: 3.6.5
  PART_SUCCESSOR produces partitions of N,

  Partitions of N = 8

 1 1 1 1 1 1 1 1
 2 1 1 1 1 1 1
 2 2 1 1 1 1
 2 2 2 1 1
 2 2 2 2
 3 1 1 1 1 1
 3 2 1 1 1
 3 2 2 1
 3 3 1 1
 3 3 2
 4 1 1 1 1
 4 2 1 1
 4 2 2
 4 3 1
 4 4
 5 1 1 1
 5 2 1
 5 3
 6 1 1
 6 2
 7 1
 8

PART_SUCCESSOR_TEST:
  Normal end of execution.

PART_TABLE_TEST
  Python version: 3.6.5
  PART_TABLE tabulates partitions of N.

    I      P(I)

     0       1
     1       1
     2       2
     3       3
     4       5
     5       7
     6      11
     7      15
     8      22
     9      30
    10      42

PART_TABLE_TEST:
  Normal end of execution.

PARTN_ENUM_TEST
  Python version: 3.6.5
  PARTN_ENUM enumerates partitions of N with maximum part NMAX.

   NMAX:      1       2       3       4       5       6
   N
   0:  
   1:         1
   2:         1       1
   3:         1       1       1
   4:         1       2       1       1
   5:         1       2       2       1       1
   6:         1       3       3       2       1       1
   7:         1       3       4       3       2       1
   8:         1       4       5       5       3       2
   9:         1       4       7       6       5       3
  10:         1       5       8       9       7       5

PARTN_ENUM_TEST:
  Normal end of execution.

PARTN_SF_CHECK TEST
  Python version: 3.6.5
  PARTN_SF_CHECK checks a standard form partition
  of N with largest entry NMAX.

  Partition in SF form.
  Partition of N = 0
  Maximum entry NMAX = 6
  Number of parts NPART = 4
 6 4 4 1
  Check = False

  Partition in SF form.
  Partition of N = 15
  Maximum entry NMAX = 6
  Number of parts NPART = 0
(empty vector)
  Check = False

  Partition in SF form.
  Partition of N = 15
  Maximum entry NMAX = 6
  Number of parts NPART = 4
 6 6 6 -3
  Check = False

  Partition in SF form.
  Partition of N = 15
  Maximum entry NMAX = 6
  Number of parts NPART = 4
 8 4 2 1
  Check = False

  Partition in SF form.
  Partition of N = 15
  Maximum entry NMAX = 6
  Number of parts NPART = 4
 1 4 4 6
  Check = False

  Partition in SF form.
  Partition of N = 15
  Maximum entry NMAX = 6
  Number of parts NPART = 4
 6 5 4 1
  Check = False

  Partition in SF form.
  Partition of N = 15
  Maximum entry NMAX = 6
  Number of parts NPART = 4
 6 4 4 1
  Check = True

PARTN_SF_CHECK_TEST:
  Normal end of execution.

PARTN_SUCCESSOR_TEST
  Python version: 3.6.5
  PARTN_SUCCESSOR lists partitions of N with maximum element NMAX.

  Here, N = 11
  NMAX = 4

 4 1 1 1 1 1 1 1
 4 2 1 1 1 1 1
 4 2 2 1 1 1
 4 2 2 2 1
 4 3 1 1 1 1
 4 3 2 1 1
 4 3 2 2
 4 3 3 1
 4 4 1 1 1
 4 4 2 1
 4 4 3

PARTN_SUCCESSOR_TEST:
  Normal end of execution.

PARTITION_GREEDY_TEST
  Python version: 3.6.5
  PARTITION_GREEDY partitions an integer vector into
  two subsets with nearly equal sum.

  Data set #0 partitioned:

          10
     9
     8
           7
           5
     5
           3
     3
           2
     2

  Sums:

    27    27

  Data set #1 partitioned:

        1003
   885
   854
         771
   734
         486
         281
   121
          83
    62

  Sums:

  2656  2624

PARTITION_GREEDY_TEST:
  Normal end of execution.

PERM_CHECK TEST
  Python version: 3.6.5
  PERM_CHECK checks a permutation.
  Permutation: 5 1 8 3 4
  Check = False
  Permutation: 5 1 4 3 4
  Check = False
  Permutation: 5 1 2 3 4
  Check = True

PERM_CHECK_TEST:
  Normal end of execution.

PERM_ENUM_TEST
  Python version: 3.6.5
  PERM_ENUM enumerates permutations of N items.

   N       #

   0       1
   1       1
   2       2
   3       6
   4      24
   5     120
   6     720
   7    5040
   8   40320
   9  362880
  10  3628800

PERM_ENUM_TEST:
  Normal end of execution.

PERM_INV_TEST
  Python version: 3.6.5
  PERM_INV computes an inverse permutation.

  The permutation P:

     1   2   3   4
     3   1   2   4

  The inverse permutation Q:

     1   2   3   4
     2   3   1   4

  The product R = P * Q:

     1   2   3   4
     1   2   3   4

PERM_INV_TEST:
  Normal end of execution.

PERM_LEX_RANK_TEST
  Python version: 3.6.5
  PERM_LEX_RANK ranks
  permutations using the lexicographic ordering.

  Element to be ranked:

     1   2   3   4
     3   1   2   4

  The rank is computed to be 48.

PERM_LEX_RANK_TEST:
  Normal end of execution.

PERM_LEX_SUCCESSOR_TEST
  Python version: 3.6.5
  PERM_LEX_SUCCESSOR lists
  permutations using the lexicographic ordering.
 1 2 3 4
 1 2 4 3
 1 3 2 4
 1 3 4 2
 1 4 2 3
 1 4 3 2
 2 1 3 4
 2 1 4 3
 2 3 1 4
 2 3 4 1
 2 4 1 3
 2 4 3 1
 3 1 2 4
 3 1 4 2
 3 2 1 4
 3 2 4 1
 3 4 1 2
 3 4 2 1
 4 1 2 3
 4 1 3 2
 4 2 1 3
 4 2 3 1
 4 3 1 2
 4 3 2 1

PERM_LEX_SUCCESSOR_TEST:
  Normal end of execution.

PERM_LEX_UNRANK_TEST
  Python version: 3.6.5
  PERM_LEX_UNRANK unranks
  permutations using the lexicographic ordering.

  The element of rank 12:

     1   2   3   4
     3   1   2   4

PERM_LEX_UNRANK_TEST:
  Normal end of execution.

PERM_MUL_TEST
  Python version: 3.6.5
  PERM_MUL multiplies two permutations.

  The permutation P:

     1   2   3   4
     3   1   2   4

  The permutation Q:

     1   2   3   4
     2   3   1   4

  The product R = P * Q:

     1   2   3   4
     1   2   3   4

PERM_MUL_TEST:
  Normal end of execution.

PERM_PARITY_TEST
  Python version: 3.6.5
  PERM_PARITY computes the parity of a permutation.

  The permutation P:

     1   2   3   4   5
     2   5   1   3   4

  The parity is 0

  The permutation P:

     1   2   3   4   5
     3   2   1   4   5

  The parity is 1

  The permutation P:

     1   2   3   4   5
     1   4   3   2   5

  The parity is 1

  The permutation P:

     1   2   3   4   5
     3   5   2   4   1

  The parity is 1

  The permutation P:

     1   2   3   4   5
     5   3   2   4   1

  The parity is 0

PERM_PARITY_TEST:
  Normal end of execution.

PERM_PRINT_TEST
  Python version: 3.6.5
  PERM_PRINT prints a permutation of (1,...,N).

  A 1-based permutation:

     1   2   3   4   5   6   7
     7   2   4   1   5   3   6

PERM_PRINT_TEST
  Normal end of execution.

PERM_RANDOM_TEST
  Python version: 3.6.5
  PERM_RANDOM randomly selects a permutation of 1, ..., N.

 2 5 1 3 4
 3 2 1 4 5
 1 4 3 2 5
 3 5 2 4 1
 5 3 2 4 1

PERM_RANDOM_TEST:
  Normal end of execution.

PERM_TJ_RANK_TEST
  Python version: 3.6.5
  PERM_TJ_RANK ranks
  permutations using the Trotter-Johnson ordering.

  Element to be ranked:

     1   2   3   4
     4   3   2   1

  The rank is computed to be 12.

PERM_TJ_RANK_TEST:
  Normal end of execution.

PERM_TJ_SUCCESSOR_TEST
  Python version: 3.6.5
  PERM_TJ_SUCCESSOR lists
  permutations using the Trotter-Johnson ordering.
 1 2 3 4
 1 2 4 3
 1 4 2 3
 4 1 2 3
 4 1 3 2
 1 4 3 2
 1 3 4 2
 1 3 2 4
 3 1 2 4
 3 1 4 2
 3 4 1 2
 4 3 1 2
 4 3 2 1
 3 4 2 1
 3 2 4 1
 3 2 1 4
 2 3 1 4
 2 3 4 1
 2 4 3 1
 4 2 3 1
 4 2 1 3
 2 4 1 3
 2 1 4 3
 2 1 3 4

PERM_TJ_SUCCESSOR_TEST:
  Normal end of execution.

PERM_TJ_UNRANK_TEST
  Python version: 3.6.5
  PERM_TJ_UNRANK unranks
  permutations using the Trotter-Johnson ordering.

  The element of rank 12:

     1   2   3   4
     4   3   2   1

PERM_TJ_UNRANK_TEST:
  Normal end of execution.

PERM_TO_CYCLE_TEST
  Python version: 3.6.5
  PERM_TO_CYCLE converts a permutation from
  array to cycle form.

  Permutation:

     1   2   3   4   5   6   7
     4   5   1   2   3   6   7

  Corresponding cycle form:
  Number of cycles is 3

       4   2   5   3   1
       6
       7

PERM_TO_CYCLE_TEST:
  Normal end of execution.

PRUEFER_CHECK TEST
  Python version: 3.6.5
  PRUEFER_CHECK checks a Pruefer code.

     Check?   N      P(1:N-2)

      False   2:  
       True   3:     1
      False   4:     5   2
       True   5:     5   1   3

PRUEFER_CHECK_TEST:
  Normal end of execution.

PRUEFER_ENUM_TEST
  Python version: 3.6.5
  PRUEFER_ENUM enumerates trees on N nodes, using the Pruefer code

   N           #

   0           1
   1           1
   2           1
   3           3
   4          16
   5         125
   6        1296
   7       16807
   8      262144
   9     4782969
  10   100000000

PRUEFER_ENUM_TEST:
  Normal end of execution.

PRUEFER_RANK_TEST
  Python version: 3.6.5
  PRUEFER_RANK ranks Pruefer codes.
  Element to be ranked: 3 1

  The rank of the element is computed as 8:

PRUEFER_RANK_TEST:
  Normal end of execution.

PRUEFER_SUCCESSOR_TEST
  Python version: 3.6.5
  PRUEFER_SUCCESSOR lists Pruefer codes.

    0      1    1
    1      1    2
    2      1    3
    3      1    4
    4      2    1
    5      2    2
    6      2    3
    7      2    4
    8      3    1
    9      3    2
   10      3    3
   11      3    4
   12      4    1
   13      4    2
   14      4    3
   15      4    4

PRUEFER_SUCCESSOR_TEST:
  Normal end of execution.

PRUEFER_TO_TREE_TEST
  Python version: 3.6.5
  PRUEFER_TO_TREE converts a Pruefer code to a tree;

  Pruefer code

     0       2
     1       1
     2       3

  Edge list of tree:

  Col:       0        1        2        3  
  Row
    0:       5        4        2        3  
    1:       2        1        3        1  

  Pruefer code

     0       5
     1       4
     2       5

  Edge list of tree:

  Col:       0        1        2        3  
  Row
    0:       3        2        4        5  
    1:       5        4        5        1  

  Pruefer code

     0       5
     1       1
     2       4

  Edge list of tree:

  Col:       0        1        2        3  
  Row
    0:       3        5        2        4  
    1:       5        1        4        1  

  Pruefer code

     0       3
     1       5
     2       1

  Edge list of tree:

  Col:       0        1        2        3  
  Row
    0:       4        3        5        2  
    1:       3        5        1        1  

  Pruefer code

     0       3
     1       1
     2       2

  Edge list of tree:

  Col:       0        1        2        3  
  Row
    0:       5        4        3        2  
    1:       3        1        2        1  

PRUEFER_TO_TREE_TEST:
  Normal end of execution.

PRUEFER_UNRANK_TEST
  Python version: 3.6.5
  PRUEFER_UNRANK unranks Pruefer codes.
  The element of rank 8: 3 1

PRUEFER_UNRANK_TEST:
  Normal end of execution.

QUEENS_TEST
  Python version: 3.6.5
  QUEENS produces nonattacking queens
  on a chessboard using a backtrack search.

 8 4 1 3 6 2 7 5
 8 3 1 6 2 5 7 4
 8 2 5 3 1 7 4 6
 8 2 4 1 7 5 3 6
 7 5 3 1 6 8 2 4
 7 4 2 8 6 1 3 5
 7 4 2 5 8 1 3 6
 7 3 8 2 5 1 6 4
 7 3 1 6 8 5 2 4
 7 2 6 3 1 4 8 5
 7 2 4 1 8 5 3 6
 7 1 3 8 6 4 2 5
 6 8 2 4 1 7 5 3
 6 4 7 1 8 2 5 3
 6 4 7 1 3 5 2 8
 6 4 2 8 5 7 1 3
 6 4 1 5 8 2 7 3
 6 3 7 4 1 8 2 5
 6 3 7 2 8 5 1 4
 6 3 7 2 4 8 1 5
 6 3 5 8 1 4 2 7
 6 3 5 7 1 4 2 8
 6 3 1 8 5 2 4 7
 6 3 1 8 4 2 7 5
 6 3 1 7 5 8 2 4
 6 2 7 1 4 8 5 3
 6 2 7 1 3 5 8 4
 6 1 5 2 8 3 7 4
 5 8 4 1 7 2 6 3
 5 8 4 1 3 6 2 7
 5 7 4 1 3 8 6 2
 5 7 2 6 3 1 8 4
 5 7 2 6 3 1 4 8
 5 7 2 4 8 1 3 6
 5 7 1 4 2 8 6 3
 5 7 1 3 8 6 4 2
 5 3 8 4 7 1 6 2
 5 3 1 7 2 8 6 4
 5 3 1 6 8 2 4 7
 5 2 8 1 4 7 3 6
 5 2 6 1 7 4 8 3
 5 2 4 7 3 8 6 1
 5 2 4 6 8 3 1 7
 5 1 8 6 3 7 2 4
 5 1 8 4 2 7 3 6
 5 1 4 6 8 2 7 3
 4 8 5 3 1 7 2 6
 4 8 1 5 7 2 6 3
 4 8 1 3 6 2 7 5
 4 7 5 3 1 6 8 2
 4 7 5 2 6 1 3 8
 4 7 3 8 2 5 1 6
 4 7 1 8 5 2 6 3
 4 6 8 3 1 7 5 2
 4 6 8 2 7 1 3 5
 4 6 1 5 2 8 3 7
 4 2 8 6 1 3 5 7
 4 2 8 5 7 1 3 6
 4 2 7 5 1 8 6 3
 4 2 7 3 6 8 5 1
 4 2 7 3 6 8 1 5
 4 2 5 8 6 1 3 7
 4 1 5 8 6 3 7 2
 4 1 5 8 2 7 3 6
 3 8 4 7 1 6 2 5
 3 7 2 8 6 4 1 5
 3 7 2 8 5 1 4 6
 3 6 8 2 4 1 7 5
 3 6 8 1 5 7 2 4
 3 6 8 1 4 7 5 2
 3 6 4 2 8 5 7 1
 3 6 4 1 8 5 7 2
 3 6 2 7 5 1 8 4
 3 6 2 7 1 4 8 5
 3 6 2 5 8 1 7 4
 3 5 8 4 1 7 2 6
 3 5 7 1 4 2 8 6
 3 5 2 8 6 4 7 1
 3 5 2 8 1 7 4 6
 3 1 7 5 8 2 4 6
 2 8 6 1 3 5 7 4
 2 7 5 8 1 4 6 3
 2 7 3 6 8 5 1 4
 2 6 8 3 1 4 7 5
 2 6 1 7 4 8 3 5
 2 5 7 4 1 8 6 3
 2 5 7 1 3 8 6 4
 2 4 6 8 3 1 7 5
 1 7 5 8 2 4 6 3
 1 7 4 6 8 2 5 3
 1 6 8 3 7 4 2 5
 1 5 8 6 3 7 2 4

QUEENS_TEST:
  Normal end of execution.

R8_CHOOSE_TEST
  Python version: 3.6.5
  R8_CHOOSE evaluates C(N,K).

         N         K       CNK

         0         0               1

         1         0               1
         1         1               1

         2         0               1
         2         1               2
         2         2               1

         3         0               1
         3         1               3
         3         2               3
         3         3               1

         4         0               1
         4         1               4
         4         2               6
         4         3               4
         4         4               1

         5         0               1
         5         1               5
         5         2              10
         5         3              10
         5         4               5
         5         5               1

R8_CHOOSE_TEST
  Normal end of execution.

R8_GAMMA_LOG_TEST:
  Python version: 3.6.5
  R8_GAMMA_LOG evaluates the logarithm of the Gamma function.

      X            GAMMA_LOG(X)    R8_GAMMA_LOG(X)

           0.2         1.524063822430784         1.524063822430784
           0.4        0.7966778177017837        0.7966778177017837
           0.6        0.3982338580692348        0.3982338580692349
           0.8        0.1520596783998375        0.1520596783998376
             1                         0                         0
           1.1      -0.04987244125983972      -0.04987244125983976
           1.2      -0.08537409000331583      -0.08537409000331585
           1.3       -0.1081748095078604       -0.1081748095078605
           1.4       -0.1196129141723712       -0.1196129141723713
           1.5       -0.1207822376352452       -0.1207822376352453
           1.6       -0.1125917656967557       -0.1125917656967558
           1.7      -0.09580769740706586      -0.09580769740706586
           1.8      -0.07108387291437215      -0.07108387291437215
           1.9      -0.03898427592308333      -0.03898427592308337
             2                         0                         0
             3        0.6931471805599453        0.6931471805599454
             4         1.791759469228055         1.791759469228055
            10         12.80182748008147         12.80182748008147
            20         39.33988418719949         39.33988418719949
            30         71.25703896716801           71.257038967168

R8_GAMMA_LOG_TEST
  Normal end of execution.

R8VEC_BACKTRACK_TEST
  Python version: 3.6.5
  R8VEC_BACKTRACK uses backtracking, seeking a vector X of
  N values which satisfies some condition.

  In this demonstration, we have 8 values W(I).
  We seek all subsets that sum to 53.0.
  X(I) is 0.0 or 1.0 if the entry is skipped or used.

   1     53:    15  22  16
   2     53:    15  14  16  8
   3     53:    22  14  9  8

  Done!

R8VEC_BACKTRACK_TEST:
  Normal end of execution.

RGF_CHECK TEST
  Python version: 3.6.5
  RGF_CHECK checks a restricted growth function.
  RGF:(empty vector)
  Check = False
  RGF: 0 1 2 3 4 5 6
  Check = False
  RGF: 1 3 5 8 9 10 12
  Check = False
  RGF: 1 2 3 1 4 5 4
  Check = True

RGF_CHECK_TEST:
  Normal end of execution.

RGF_ENUM_TEST
  Python version: 3.6.5
  RGF_ENUM enumerates restricted growth functions.

   N       #

   0       1
   1       1
   2       2
   3       5
   4      15
   5      52
   6     203
   7     877
   8    4140
   9   21147
  10  115975

RGF_ENUM_TEST:
  Normal end of execution.

RGF_RANK_TEST
  Python version: 3.6.5
  RGF_RANK ranks restricted growth functions.
  Element to be ranked: 1 2 1 3

  The rank of the element is computed as 7:

RGF_RANK_TEST:
  Normal end of execution.

RGF_SUCCESSOR_TEST
  Python version: 3.6.5
  RGF_SUCCESSOR lists restricted growth functions.

 1 1 1 1
 1 1 1 2
 1 1 2 1
 1 1 2 2
 1 1 2 3
 1 2 1 1
 1 2 1 2
 1 2 1 3
 1 2 2 1
 1 2 2 2
 1 2 2 3
 1 2 3 1
 1 2 3 2
 1 2 3 3
 1 2 3 4

RGF_SUCCESSOR_TEST:
  Normal end of execution.

RGF_TO_SETPART_TEST
  Python version: 3.6.5
  RGF_TO_SETPART converts a balanced
  sequence to a restricted growth function
  Restricted growth function: 1 1 1 1 1 2 1 3

  Corresponding set partition:

   1   2   3   4   5   7
   6
   8

RGF_TO_SETPART_TEST:
  Normal end of execution.

RGF_UNRANK_TEST
  Python version: 3.6.5
  RGF_UNRANK unranks restricted growth functions.
  The element of rank 7 1 2 1 3

RGF_UNRANK_TEST:
  Normal end of execution.

RGF_G_TABLE_TEST
  Python version: 3.6.5
  RGF_G_TABLE tabulates generalized restricted
  growth functions.

     1     1     1     1     1     1     1
     1     2     3     4     5     6
     2     5    10    17    26
     5    15    37    77
    15    52   151
    52   203
   203

RGF_G_TABLE_TEST:
  Normal end of execution.

SETPART_CHECK TEST
  Python version: 3.6.5
  SETPART_CHECK checks a set partition.

  The set partition
  M = 0
  NSUB = 3

   3   6
   1   4   7
   2   5   8
  Check = False

  The set partition
  M = 8
  NSUB = 0

  Check = False

  The set partition
  M = 8
  NSUB = 3

   3   6
   1   4   7   2   5   8

  Check = False

  The set partition
  M = 8
  NSUB = 3

   3   6
   1   4   9
   2   5   8
  Check = False

  The set partition
  M = 8
  NSUB = 3

   3   6
   1   4   6
   2   5   8
  Check = False

  The set partition
  M = 8
  NSUB = 3

   3   6
   1   4   7
   2   5   8
  Check = True

SETPART_CHECK_TEST:
  Normal end of execution.

SETPART_ENUM_TEST
  Python version: 3.6.5
  SETPART_ENUM enumerates set partitions.

     1     1
     2     2
     3     5
     4    15
     5    52
     6   203

SETPART_ENUM_TEST:
  Normal end of execution.

SETPART_TO_RGF_TEST
  Python version: 3.6.5
  SETPART_TO_RGF converts a set partition
  to a restricted growth function.

  The set partition
  M = 8
  NSUB = 3

   1   2   3   4   5   6
   7
   8
  Recovered restricted growth function: 1 1 1 1 1 1 2 3

SETPART_TO_RGF_TEST:
  Normal end of execution.

STIRLING_NUMBERS1_TEST
  Python version: 3.6.5
  STIRLING_NUMBERS1 computes a table of Stirling
  numbers of the first kind.

  Stirling numbers:

  Col:       0        1        2        3        4  
  Row
    0:       1        0        0        0        0  
    1:       0        1        0        0        0  
    2:       0       -1        1        0        0  
    3:       0        2       -3        1        0  
    4:       0       -6       11       -6        1  
    5:       0       24      -50       35      -10  
    6:       0     -120      274     -225       85  

  Col:       5        6  
  Row
    0:       0        0  
    1:       0        0  
    2:       0        0  
    3:       0        0  
    4:       0        0  
    5:       1        0  
    6:     -15        1  

STIRLING_NUMBERS1_TEST:
  Normal end of execution.

STIRLING_NUMBERS2_TEST
  Python version: 3.6.5
  STIRLING_NUMBERS2 computes a table of Stirling
  numbers of the second kind.

  Stirling numbers:

  Col:       0        1        2        3        4  
  Row
    0:       1        0        0        0        0  
    1:       0        1        0        0        0  
    2:       0        1        1        0        0  
    3:       0        1        3        1        0  
    4:       0        1        7        6        1  
    5:       0        1       15       25       10  
    6:       0        1       31       90       65  

  Col:       5        6  
  Row
    0:       0        0  
    1:       0        0  
    2:       0        0  
    3:       0        0  
    4:       0        0  
    5:       1        0  
    6:      15        1  

STIRLING_NUMBERS2_TEST:
  Normal end of execution.

SUBSET_CHECK TEST
  Python version: 3.6.5
  SUBSET_CHECK checks a subset.
  Subset:(empty vector)
  Check = False
  Subset: 1 2 0
  Check = False
  Subset: 1 0 0 1 0
  Check = True

SUBSET_CHECK_TEST:
  Normal end of execution.

SUBSET_COLEX_RANK_TEST
  Python version: 3.6.5
  SUBSET_COLEX_RANK ranks subsets of a set,
  using the colexicographic ordering.
  The element: 0 1 0 1 0

  The rank of the element is computed as 10:

SUBSET_COLEX_RANK_TEST:
  Normal end of execution.

SUBSET_COLEX_SUCCESSOR_TEST
  Python version: 3.6.5
  SUBSET_COLEX_SUCCESSOR lists subsets of a set,
  using the colexicographic ordering.
 0 0 0 0 0
 1 0 0 0 0
 0 1 0 0 0
 1 1 0 0 0
 0 0 1 0 0
 1 0 1 0 0
 0 1 1 0 0
 1 1 1 0 0
 0 0 0 1 0
 1 0 0 1 0
 0 1 0 1 0
 1 1 0 1 0
 0 0 1 1 0
 1 0 1 1 0
 0 1 1 1 0
 1 1 1 1 0
 0 0 0 0 1
 1 0 0 0 1
 0 1 0 0 1
 1 1 0 0 1
 0 0 1 0 1
 1 0 1 0 1
 0 1 1 0 1
 1 1 1 0 1
 0 0 0 1 1
 1 0 0 1 1
 0 1 0 1 1
 1 1 0 1 1
 0 0 1 1 1
 1 0 1 1 1
 0 1 1 1 1
 1 1 1 1 1

SUBSET_COLEX_SUCCESSOR_TEST:
  Normal end of execution.

SUBSET_COLEX_UNRANK_TEST
  Python version: 3.6.5
  SUBSET_COLEX_UNRANK unranks subsets of a set,
  using the colexicographic ordering.
  The subset of rank 10: 0 1 0 1 0

SUBSET_COLEX_UNRANK_TEST:
  Normal end of execution.

SUBSET_COMPLEMENT_TEST
  Python version: 3.6.5
  SUBSET_COMPLEMENT returns the complement of a subset.
  Subset S1: 0 1 1 1 0
  S2 = complement of S1: 1 0 0 0 1

SUBSET_COMPLEMENT_TEST:
  Normal end of execution.

SUBSET_DISTANCE_TEST
  Python version: 3.6.5
  SUBSET_DISTANCE returns the distance between two subsets.
  Subset S1: 0 1 1 1 0 0 0 0 0 1
  Subset S2: 0 0 0 1 1 0 1 0 0 0

  Distance between S1 and S2 is 5

SUBSET_DISTANCE_TEST:
  Normal end of execution.

SUBSET_ENUM_TEST
  Python version: 3.6.5
  SUBSET_ENUM enumerates subsets of a set of N items.

   N       #

   0       1
   1       2
   2       4
   3       8
   4      16
   5      32
   6      64
   7     128
   8     256
   9     512
  10    1024

SUBSET_ENUM_TEST:
  Normal end of execution.

SUBSET_INTERSECT_TEST
  Python version: 3.6.5
  SUBSET_INTERSECT returns the intersection of two subsets.
  Subset S1: 0 1 1 1 0 0 0 0 0 1
  Subset S2: 0 0 0 1 1 0 1 0 0 0
  Intersection S3: 0 0 0 1 0 0 0 0 0 0

SUBSET_INTERSECT_TEST:
  Normal end of execution.

SUBSET_LEX_RANK_TEST
  Python version: 3.6.5
  SUBSET_LEX_RANK ranks subsets of a set,
  using the lexicographic ordering.
  The element: 0 1 0 1 0

  The rank of the element is computed as 10

SUBSET_LEX_RANK_TEST:
  Normal end of execution.

SUBSET_LEX_SUCCESSOR_TEST
  Python version: 3.6.5
  SUBSET_LEX_SUCCESSOR lists subsets of a set,
  using the lexicographic ordering.
 0 0 0 0 0
 0 0 0 0 1
 0 0 0 1 0
 0 0 0 1 1
 0 0 1 0 0
 0 0 1 0 1
 0 0 1 1 0
 0 0 1 1 1
 0 1 0 0 0
 0 1 0 0 1
 0 1 0 1 0
 0 1 0 1 1
 0 1 1 0 0
 0 1 1 0 1
 0 1 1 1 0
 0 1 1 1 1
 1 0 0 0 0
 1 0 0 0 1
 1 0 0 1 0
 1 0 0 1 1
 1 0 1 0 0
 1 0 1 0 1
 1 0 1 1 0
 1 0 1 1 1
 1 1 0 0 0
 1 1 0 0 1
 1 1 0 1 0
 1 1 0 1 1
 1 1 1 0 0
 1 1 1 0 1
 1 1 1 1 0
 1 1 1 1 1

SUBSET_LEX_SUCCESSOR_TEST:
  Normal end of execution.

SUBSET_LEX_UNRANK_TEST
  Python version: 3.6.5
  SUBSET_LEX_UNRANK unranks subsets of a set,
  using the lexicographic ordering.
  The element of rank 10: 0 1 0 1 0

SUBSET_LEX_UNRANK_TEST:
  Normal end of execution.

SUBSET_RANDOM_TEST
  Python version: 3.6.5
  SUBSET_RANDOM returns a random subset.
  Subset: 0 1 1 1 0
  Subset: 0 0 0 0 1
  Subset: 0 0 0 1 1
  Subset: 0 1 0 0 0
  Subset: 1 1 0 0 0
  Subset: 1 0 0 1 0
  Subset: 1 1 1 0 1
  Subset: 1 0 1 0 0
  Subset: 1 0 1 0 0
  Subset: 1 0 0 1 1

SUBSET_RANDOM_TEST:
  Normal end of execution.

SUBSET_UNION_TEST
  Python version: 3.6.5
  SUBSET_UNION returns the union of two subsets.
  Subset S1: 0 1 1 1 0 0 0 0 0 1
  Subset S2: 0 0 0 1 1 0 1 0 0 0
  Union S3: 0 1 1 1 1 0 1 0 0 1

SUBSET_UNION_TEST:
  Normal end of execution.

SUBSET_WEIGHT_TEST
  Python version: 3.6.5
  SUBSET_WEIGHT returns the weight of a subset.
  Subset S1: 0 1 1 1 0 0 0 0 0 1

  The weight of the subset is 4

SUBSET_WEIGHT_TEST:
  Normal end of execution.

SUBSET_XOR_TEST
  Python version: 3.6.5
  SUBSET_XOR returns the exclusive OR of two subsets.
  Subset S1: 0 1 1 1 0 0 0 0 0 1
  Subset S2: 0 0 0 1 1 0 1 0 0 0
  S3 = S1 xor S2: 0 1 1 0 1 0 1 0 0 1

SUBSET_XOR_TEST:
  Normal end of execution.

SUBSETSUM_SWAP_TEST
  Python version: 3.6.5
  SUBSETSUM_SWAP seeks a solution of the subset
  sum problem using pair swapping.

  The desired sum is 17

    A(I), INDEX(I)

     30      0
     12      1
     11      0
      8      0
      8      0
      7      0
      3      1

  The achieved sum is 15

SUBSETSUM_SWAP_TEST:
  Normal end of execution.

TABLEAU_CHECK TEST
  Python version: 3.6.5
  TABLEAU_CHECK checks a 2xN tableau.

  Check?


      Check =  0

  Tableau:

  (None)

      Check =  0

  Tableau:

  Col:       0        1        2        3  
  Row
    0:       1        2        3        4  
    1:       2        4        7        9  

      Check =  0

  Tableau:

  Col:       0        1        2        3  
  Row
    0:       1        3        5        3  
    1:       2        4        5        3  

      Check =  0

  Tableau:

  Col:       0        1        2        3  
  Row
    0:       1        3        4        5  
    1:       2        4        5        3  

      Check =  1

  Tableau:

  Col:       0        1        2        3  
  Row
    0:       1        3        6        7  
    1:       3        4        7        8  

TABLEAU_CHECK_TEST:
  Normal end of execution.

TABLEAU_ENUM_TEST
  Python version: 3.6.5
  TABLEAU_ENUM enumerates tableaus on N nodes.

   N           #

   0           1
   1           1
   2           2
   3           5
   4          14
   5          42
   6         132
   7         429
   8        1430
   9        4862
  10       16796

TABLEAU_ENUM_TEST:
  Normal end of execution.

TABLEAU_TO_BAL_SEQ_TEST
  Python version: 3.6.5
  TABLEAU_TO_BAL_SEQ converts a tableau
  to a balanced sequence.

  Tableau:

  Col:       0        1        2        3  
  Row
    0:       1        2        5        6  
    1:       3        4        7        8  
  Balanced sequence: 0 0 1 1 0 0 1 1

TABLEAU_TO_BAL_SEQ_TEST:
  Normal end of execution.

TREE_CHECK TEST
  Python version: 3.6.5
  TREE_CHECK checks a tree.

  Check?   N    T(1:N)


      Check = False

  Tree:

  (None)

      Check = True

  Tree:

  Col:       0        1  
  Row
    0:       1        2  
    1:       2        3  

      Check = False

  Tree:

  Col:       0        1        2        3  
  Row
    0:       1        3        4        5  
    1:       2        4        5        3  

      Check = True

  Tree:

  Col:       0        1        2        3        4  
  Row
    0:       1        2        3        4        5  
    1:       3        3        4        5        6  

TREE_CHECK_TEST:
  Normal end of execution.

TREE_ENUM_TEST
  Python version: 3.6.5
  TREE_ENUM enumerates trees on N nodes.

   N           #

   0           0
   1           1
   2           1
   3           3
   4          16
   5         125
   6        1296
   7       16807
   8      262144
   9     4782969
  10   100000000

TREE_ENUM_TEST:
  Normal end of execution.

TREE_RANK_TEST
  Python version: 3.6.5
  TREE_RANK ranks trees.

  The element:

  Col:       0        1        2  
  Row
    0:       4        3        3  
    1:       1        2        1  

  The rank of the element is computed as 2:

TREE_RANK_TEST:
  Normal end of execution.

TREE_SUCCESSOR_TEST
  Python version: 3.6.5
  TREE_SUCCESSOR lists trees.
    0      4    3    2
           1    1    1
    1      4    3    2
           1    2    1
    2      4    2    3
           1    3    1
    3      3    2    4
           1    4    1
    4      4    3    2
           2    1    1
    5      4    3    2
           2    2    1
    6      4    2    3
           2    3    1
    7      3    2    4
           2    4    1
    8      4    3    2
           3    1    1
    9      4    3    2
           3    2    1
   10      4    2    3
           3    3    1
   11      2    3    4
           3    4    1
   12      3    4    2
           4    1    1
   13      3    4    2
           4    2    1
   14      2    4    3
           4    3    1
   15      3    2    4
           4    4    1

TREE_SUCCESSOR_TEST:
  Normal end of execution.

TREE_TO_PRUEFER_TEST
  Python version: 3.6.5
  TREE_TO_PRUEFER converts a tree to a Pruefer code.
  Pruefer code: 2 1 3

  Edge list for corresponding tree:

  Col:       0        1        2        3  
  Row
    0:       5        4        2        3  
    1:       2        1        3        1  
  Recovered Pruefer code: 2 1 3
  Pruefer code: 5 4 5

  Edge list for corresponding tree:

  Col:       0        1        2        3  
  Row
    0:       3        2        4        5  
    1:       5        4        5        1  
  Recovered Pruefer code: 5 4 5
  Pruefer code: 5 1 4

  Edge list for corresponding tree:

  Col:       0        1        2        3  
  Row
    0:       3        5        2        4  
    1:       5        1        4        1  
  Recovered Pruefer code: 5 1 4
  Pruefer code: 3 5 1

  Edge list for corresponding tree:

  Col:       0        1        2        3  
  Row
    0:       4        3        5        2  
    1:       3        5        1        1  
  Recovered Pruefer code: 3 5 1
  Pruefer code: 3 1 2

  Edge list for corresponding tree:

  Col:       0        1        2        3  
  Row
    0:       5        4        3        2  
    1:       3        1        2        1  
  Recovered Pruefer code: 3 1 2

TREE_TO_PRUEFER_TEST:
  Normal end of execution.

TREE_UNRANK_TEST
  Python version: 3.6.5
  TREE_UNRANK unranks trees.

  The element of rank 8:

  Col:       0        1        2  
  Row
    0:       4        3        2  
    1:       3        1        1  

TREE_UNRANK_TEST:
  Normal end of execution.

COMBO_TEST:
  Normal end of execution.
Wed Sep 12 21:11:26 2018
